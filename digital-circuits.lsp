;;queue

(defun front-ptr (queue)
  (car queue))

(defun rear-ptr (queue)
  (cdr queue))

(defun set-front-ptr! (queue item)
  (setf (car queue) item))

(defun set-rear-ptr! (queue item)
  (setf (cdr queue) item))

(defun empty-queue? (queue)
  (null (front-ptr queue)))

(defun make-queue ()
  (cons '() '()))

(defun front-queue (queue)
  (if (empty-queue? queue)
      (error "FRONTED called with an empty queue")
    (car (front-ptr queue))))

(defun insert-queue! (queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
	   (set-front-ptr! queue new-pair)
	   (set-rear-ptr! queue new-pair)
	   queue)
	  (t 
	   (setf (cdr (rear-ptr queue)) new-pair)
	   (set-rear-ptr! queue new-pair)
	   queue))))

(defun delete-queue! (queue)
  (cond ((empty-queue? queue)
	 (error "DELETE! called with an empty queue"))
	(t
	 (set-front-ptr! queue (cdr (front-ptr queue)))
	 queue)))

;;agenda

(defun the-agenda ()
  (make-agenda))

(defun make-time-segment (time queue)
  (cons time queue))

(defun segment-time (s)
  (car s))

(defun segment-queue (s)
  (cdr s))

(defun make-agenda ()
  (list 0))

(defun current-time (agenda)
  (car agenda))

(defun set-current-time! (agenda time)
  (setf (car agenda) time))

(defun segments (agenda)
  (cdr agenda))

(defun set-segments! (agenda segments)
  (setf (cdr agenda) segments))

(defun first-segment (agenda)
  (car (segments agenda)))

(defun rest-segments (agenda)
  (cdr (segments agenda)))

(defun empty-agenda? (agenda)
  (null (segments agenda)))

(defun add-to-agenda! (time action agenda)
  (defun belongs-before? (segments)
    (or (null segments)
	(< time (segment-time (car segments)))))
  (defun make-new-time-segment (time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (defun add-to-segments! (segments)
    (if (= (segment-time (car segments)) time)
	(insert-queue! (segment-queue (car segments))
		       action)
      (let ((rest (cdr segments)))
	(if (belongs-before? rest)
	    (setf (cdr segments) (cons (make-new-time-segment time action)
				       (cdr segments)))
	  (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
	(set-segments!
	 agenda
	 (cons (make-new-time-segment time action)
	       segments))
      (add-to-segments! segments))))

(defun remove-first-agenda-item! (agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
	(set-segments! agenda (rest-segments agenda)))))

(defun first-agenda-item (agenda)
  (if (empty-agenda? agenda)
      (error "Agenda is empty -- FIRST-AGENDA-ITEM")
    (let ((first-seg (first-segment agenda)))
	  (set-current-time! agenda (segment-time first-seg))
	  (front-queue (segment-queue first-seg)))))

;digital-circuits

(defparameter *the-agenda* (make-agenda))
(defparameter *inverter-delay* 2)
(defparameter *and-gate-delay* 3)
(defparameter *or-gate-delay* 5)

(defun make-wire ()
  (let ((signal-value 0) (action-procedures '()))
    #'(lambda (m)
	(cond ((equal m 'get-signal) signal-value)
	      ((equal m 'set-signal!) 
	       #'(lambda (new-value)
		   (if (not (= signal-value new-value))
		       (progn (setf signal-value new-value)
			      (call-each action-procedures))
		     'done)))
	      ((equal m 'add-action!) 
	       #'(lambda (proc)
		   (setf action-procedures (cons proc action-procedures))
		   (funcall proc)))
	      (t (error "Unknown operation --WIRE"))))))

(defun call-each (procedures)
  (if (null procedures)
      'done
    (progn
      (funcall (car procedures))
      (call-each (cdr procedures)))))

(defun get-signal (wire)
  (funcall wire 'get-signal))

(defun set-signal! (wire new-value)
  (funcall (funcall wire 'set-signal!) new-value))

(defun add-action! (wire action-procedure)
  (funcall (funcall wire 'add-action!) action-procedure))

(defun after-delay (delay action)
  (add-to-agenda! (+ delay (current-time *the-agenda*))
		  action
		  *the-agenda*))

(defun propagate ()
  (if (empty-agenda? *the-agenda*)
      'done
    (let ((first-item (first-agenda-item *the-agenda*)))
      (funcall first-item)
      (remove-first-agenda-item! *the-agenda*)
      (propagate))))

(defun probe (name wire)
  (add-action! wire
	       (lambda ()
		 (print 'name)
		 (print name)
		 (print 'time)
		 (print  (current-time *the-agenda*))
		 (print 'New-value=)
		 (print  (get-signal wire)))))

;;utilities

(defun inverter (input output)
  (defun invert-input ()
    (let ((new-value (logical-not (get-signal input))))
      (after-delay *inverter-delay*
		   (lambda () 
		     (set-signal! output new-value)))))
  (add-action! input #'invert-input)
  'ok)

(defun logical-not (s)
  (cond ((= s 0) 1)
	((= s 1) 0)
	(t (error "Invalid signal"))))

(defun and-gate (a1 a2 output)
  (defun and-action-procedure ()
    (let ((new-value
	   (logical-and (get-signal a1) (get-signal a2))))
      (after-delay *and-gate-delay*
		   (lambda ()
		     (set-signal! output new-value)))))
  (add-action! a1 #'and-action-procedure)
  (add-action! a2 #'and-action-procedure)
  'ok)

(defun logical-and (s1 s2)
  (cond ((and (= s1 1) (= s2 1)) 1)
	((or (= s1 0) (= s2 0)) 0)
	(t (error "Invalid signal"))))
 
(defun or-gate (o1 o2 output)
  (defun or-action-procedure ()
    (let ((new-value (logical-or (get-signal o1) (get-signal o2))))
      (after-delay *or-gate-delay*
		   (lambda ()
		     (set-signal! output new-value)))))
  (add-action! o1 #'or-action-procedure)
  (add-action! o2 #'or-action-procedure)
  'ok)

(defun logical-or (s1 s2)
  (cond ((or (= s1 1) (= s2 1)) 1)
	((and (= s1 0) (= s2 0)) 0)
	(t (error "Invalid signal"))))

(defun nand-gate (in1 in2 out)
  (defun nand-action-procedure ()
    (let ((new-value (logical-not 
		      (logical-and (get-signal in1) (get-signal in2)))))
      (after-delay (+ *and-gate-delay* *inverter-delay*)
		   (lambda ()
		     (set-signal! out new-value)))))
  (add-action! in1 #'nand-action-procedure)
  (add-action! in2 #'nand-action-procedure)
  'ok)

(defun nor-gate (in1 in2 out)
  (defun nor-action-procedure ()
    (let ((new-value (logical-not
		      (logical-or (get-signal in1) (get-signal in2)))))
      (after-delay (+ *or-gate-delay* *inverter-delay*)
		   (lambda ()
		     (set-signal! out new-value)))))
  (add-action! in1 #'nor-action-procedure)
  (add-action! in2 #'nor-action-procedure)
  'ok)
  
(defun xor-gate (in1 in2 out)
  (defun xor-action-procedure ()
    (let ((new-value (logical-or
		      (logical-and (logical-not (get-signal in1)) (get-signal in2))
		      (logical-and (get-signal in1) (logical-not (get-signal in2))))))
      (after-delay (+ *or-gate-delay* (* 2 *and-gate-delay*))
		   (lambda ()
		     (set-signal! out new-value)))))
  (add-action! in1 #'xor-action-procedure)
  (add-action! in2 #'xor-action-procedure)
  'ok)

(defun xnor-gate (in1 in2 out)
  (defun xnor-action-procedure ()
    (let ((new-value (logical-or
		      (logical-and (get-signal in1) (get-signal in2))
		      (logical-and (logical-not (get-signal in1)) (logical-not (get-signal in2))))))
      (after-delay (+ *or-gate-delay* (* 2 *and-gate-delay*))
		   (lambda ()
		     (set-signal! out new-value)))))
  (add-action! in1 #'xnor-action-procedure)
  (add-action! in2 #'xnor-action-procedure)
  'ok)

;test
(setf wire0 (make-wire))
(setf wire1 (make-wire))
(setf wire2 (make-wire))
(setf wire3 (make-wire))
(setf wire4 (make-wire))
(setf wire5 (make-wire))
(setf wire6 (make-wire))
(setf wire7 (make-wire))
(setf wire8 (make-wire))
(setf wire9 (make-wire))
(setf wire10 (make-wire))
(setf a0 (make-wire))
(setf a1 (make-wire))
(setf a2 (make-wire))
(setf a3 (make-wire))
(setf a4 (make-wire))
(setf b0 (make-wire))
(setf b1 (make-wire))
(setf b2 (make-wire))
(setf b3 (make-wire))
(setf b4 (make-wire))

(defun 2to1 (d0 d1 s y)
  (let ((a (make-wire))
	(b (make-wire))
	(c (make-wire)))
    (and-gate s d1 b)
    (inverter s c)
    (and-gate c d0 a)
    (or-gate a b y)
    'ok))

(defun 4to1 (d0 d1 d2 d3 s0 s1 y)
  (let ((y0 (make-wire))
	(y1 (make-wire)))
    (2to1 d0 d1 s0 y0)
    (2to1 d2 d3 s0 y1)
    (2to1 y0 y1 s1 y)
    'ok))

(defun half-adder (a b s c)
  (xor-gate a b s)
  (and-gate a b c)
  'ok)

(defun full-adder (a b c-in c-out s)
  (let ((input-1 (make-wire))
	(input-2 (make-wire))
	(input-3 (make-wire)))
    (half-adder a b input-1 input-2)
    (half-adder input-1 c-in s input-3)
    (or-gate input-3 input-2 c-out)
    'ok))

;4-bit carry ripple adder
(defun 4-cra (a0 a1 a2 a3 b0 b1 b2 b3 s0 s1 s2 s3 c3)
  (let ((c-1 (make-wire))
	(c0 (make-wire))
	(c1 (make-wire))
	(c2 (make-wire)))
    (set-signal! c-1 0)
    (full-adder a0 b0 c-1 c0 s0)
    (full-adder a1 b1 c0 c1 s1)
    (full-adder a2 b2 c1 c2 s2)
    (full-adder a3 b3 c2 c3 s3)
    'ok))

(defun sr-latch (s r q !q)
  (set-signal! !q 1);this is essential
  (nor-gate r !q q)
  (nor-gate s q !q)
  'ok)

(defun d-latch (e d q !q)
  (let ((input-1 (make-wire))
	(input-2 (make-wire))
	(input-3 (make-wire)))
    (inverter d input-1)
    (and-gate input-1 e input-2)
    (and-gate e d input-3)
    (sr-latch input-3 input-2 q !q)
    'ok))

;master-slaver D flip-flop
(defun d-ff (cp d q !q)
  (let ((q1 (make-wire))
	(!q1 (make-wire))
	(!cp (make-wire)))
    (inverter cp !cp)
    (d-latch !cp d q1 !q1)
    (d-latch cp q1 q !q)
    'ok))

(defun d-ff-sr (cp d !s !r q !q)
  (let ((in-1 (make-wire))
	(in-2 (make-wire))
	(in-3 (make-wire))
	(in-4 (make-wire))
	(in-5 (make-wire))
	(in-6 (make-wire))
	(in-7 (make-wire))
	(in-8 (make-wire))
	(in-9 (make-wire))
	(in-10 (make-wire))
	(in-13 (make-wire))
	(in-14 (make-wire))
	(!cp (make-wire)))
    (inverter cp !cp)
    (inverter d in-1)
    (inverter in-4 in-8)
    (set-signal! !s 1)
    (set-signal! !r 1)
    (set-signal! in-5 1)
    (set-signal! in-7 1)
    (set-signal! in-14 1)
    (set-signal! !q 1)
    (and-gate in-1 !cp in-2)
    (and-gate !cp d in-3)
    (nor-gate in-2 in-5 in-6)
    (nor-gate in-3 in-4 in-7)
    (and-gate in-6 !s in-4)
    (and-gate in-7 !r in-5)
    (and-gate in-8 cp in-9)
    (and-gate in-4 cp in-10)
    (nor-gate in-9 !q in-13)
    (nor-gate in-10 q in-14)
    (and-gate in-13 !r q)
    (and-gate in-14 !s !q)
    'ok))

(defun jk-ff (cp j k q !q)
  (let ((!k (make-wire))
	(in-1 (make-wire))
	(in-2 (make-wire))
	(in-3 (make-wire)))
    (inverter k !k)
    (and-gate !q j in-1)
    (and-gate q !k in-2)
    (or-gate in-1 in-2 in-3)
    (d-ff cp in-3 q !q)
    'ok))

(defun t-ff (cp toggle q !q)
  (let ((in-1 (make-wire)))
    (xor-gate toggle q in-1)
    (d-ff cp in-1 q !q)
    'ok))

;versatile-4-bidirectional-shift-register
(defun 4-bsr (cp s0 s1 d-sr d0 d1 d2 d3 d-sl q0 q1 q2 q3)
  (let ((in-1 (make-wire))
	(in-2 (make-wire))
	(in-3 (make-wire))
	(in-4 (make-wire))
	(in-5 (make-wire))
	(in-6 (make-wire))
	(in-7 (make-wire))
	(in-8 (make-wire)))
    (4to1 q0 d-sr q1 d0 s0 s1 in-1)
    (d-ff cp in-1 q0 in-5)
    (4to1 q1 q0 q2 d1 s0 s1 in-2)
    (d-ff cp in-2 q1 in-6)
    (4to1 q2 q1 q3 d2 s0 s1 in-3)
    (d-ff cp in-3 q2 in-7)
    (4to1 q3 q2 d-sl d3 s0 s1 in-4)
    (d-ff cp in-4 q3 in-8)
    'ok))

;4-synchronous-binary-counter
(defun 4-sbc (cp q0 q1 q2 q3)
  (let ((in-1 (make-wire))
	(in-2 (make-wire))
	(in-3 (make-wire))
	(in-4 (make-wire))
	(in-5 (make-wire))
	(in-6 (make-wire))
	(in-7 (make-wire))
	(!cp (make-wire)))
    (inverter cp !cp)
    (set-signal! in-1 1)
    (t-ff !cp in-1 q0 in-2)
    (t-ff !cp q0 q1 in-3)
    (and-gate q0 q1 in-4)
    (t-ff !cp in-4 q2 in-5)
    (and-gate q2 in-4 in-6)
    (t-ff !cp in-6 q3 in-7)
    'ok))

;versatile-4-synchronous-binary-counter
(defun v4-sbc (cp !cr !pe cep cet d0 d1 d2 d3 tc q0 q1 q2 q3)
  (let ((in-1 (make-wire))
	(in-2 (make-wire))
	(in-3 (make-wire))
	(in-4 (make-wire))
	(in-5 (make-wire))
	(in-6 (make-wire))
	(in-7 (make-wire))
	(in-8 (make-wire))
	(in-9 (make-wire))
	(in-10 (make-wire))
	(in-11 (make-wire))
	(in-12 (make-wire))
	(tmp1 (make-wire))
	(tmp2 (make-wire))
	(tmp3 (make-wire))
	(tmp4 (make-wire))
	(tmp5 (make-wire))
	(tmp6 (make-wire))
	(!s0 (make-wire))
	(!s1 (make-wire))
	(!s2 (make-wire))
	(!s3 (make-wire))
	(!q0 (make-wire))
	(!q1 (make-wire))
	(!q2 (make-wire))
	(!q3 (make-wire)))
    (and-gate cet cep in-1)
    (xor-gate in-1 q0 in-2)
    (2to1 d0 in-2 !pe in-6)
    (d-ff-sr cp in-6 !s0 !cr q0 !q0)
    (and-gate in-1 q0 in-10)
    (xor-gate in-10 q1 in-3)
    (2to1 d1 in-3 !pe in-7)
    (d-ff-sr cp in-7 !s1 !cr q1 !q1)
    (and-gate in-1 q1 tmp1)
    (and-gate tmp1 q0 in-11)
    (xor-gate in-11 q2 in-4)
    (2to1 d2 in-4 !pe in-8)
    (d-ff-sr cp in-8 !s2 !cr q2 !q2)
    (and-gate in-1 q2 tmp2)
    (and-gate q0 q1 tmp3)
    (and-gate tmp2 tmp3 in-12)
    (xor-gate in-12 q3 in-5)
    (2to1 d3 in-5 !pe in-9)
    (d-ff-sr cp in-9 !s3 !cr q3 !q3)
    (and-gate q3 q2 tmp4)
    (and-gate q1 q0 tmp5)
    (and-gate tmp4 tmp5 tmp6)
    (and-gate tmp6 cet tc)
    'ok))

(setf cp (make-wire))
(setf !cr (make-wire))
(setf !pe (make-wire))
(setf cep (make-wire))
(setf cet (make-wire))
(setf d0 (make-wire))
(setf d1 (make-wire))
(setf d2 (make-wire))
(setf d3 (make-wire))
(setf tc (make-wire))
(setf q0 (make-wire))
(setf q1 (make-wire))
(setf q2 (make-wire))
(setf q3 (make-wire))

;stream

(defmacro delay (expr)
  `#'(lambda () ,expr))

(defun force (x)
  (funcall x))

(defmacro cons-stream (x y)
  `(cons ,x (delay ,y)))

(defun stream-for-each (s proc test)
  (if (funcall test (car s))
      'done
    (and 
     (funcall proc (car s))
     (stream-for-each (funcall (cdr s)) proc test))))

(defun oscillation (init)
       (if (= init 0)
	   (cons-stream init (oscillation 1))
	 (cons-stream init (oscillation 0))))

(defun clock (generator wire times)
  (let ((x (car generator)))
    (if (< times 0) 
	'done
      (and
       (set-signal! wire x)
       (propagate)
       (clock (funcall (cdr generator))
	      wire
	      (1- times))))))
